# CHAPTER 1

웹 프로그래밍의 이해

## 1.1 웹 프로그래밍이란?

HTTP(S) 프로토콜로 통신하는, 클라이언트와 서버를 개발하는 것.

* 웹 서버
  * 웹 프레임워크를 활용하여 웹 서버를 개발함.
* 웹 클라이언트
  1. 웹 브라우저를 사용하여 요청
  2. 리눅스 ```curl``` 명령을 사용하여 요청
  3. Telnet을 사용하여 요청
  4. 직접 만든 클라이언트로 요청

## 1.2 다양한 웹 클라이언트

```www.example.com``` 도메인의 웹 서버를 대상으로 HTTP Request와 Response를 확인해본다.

### 1.2.1 웹 브라우저를 사용하여 요청

웹 브라우저에 ```www.example.com```을 입력

### 1.2.2. 리눅스 curl 명령을 사용하여 요청

```curl``` 명령은 HTTP/HTTPS/FTP 등 여러 가지의 프로토콜을 사용하여 데이터를 송수신할 수 있는 명령이다.
인자로 넘오온 URL로 HTTP 요청을 보내는 웹 클라이언트의 역할을 수행한다.

```bash
$ curl http://www.example.com
```

### 1.2.3 Telnet을 사용하여 요청

리눅스의 ```telnet``` 프로그램을 사용하여 HTTP 요청을 보낸다.

```bash
$ telnet www.example.com 80
```

telnet 명령은 터미널 창에서 입력하는 내용을 그대로 웹 서버에 전송한다.

### 1.2.4 직접 만든 클라이언트로 요청

파이썬 프로그램으로 간단한 웹 클라이언트를 만들어 요청을 보낸다.


example.py
```python
import urllib.request
print(urllib.request.urlopen("http://www.example.com").read().decode('utf-8'))
```

```bash
$ python example.py
```

## 1.3 HTTP 프로토콜

HTTP
* Hypertext Transfer Protocol은 웹 서버와 웹 클라이언트 사이에서 데이터를 주고받기 위해 사용하는 통신 방식
* TCP/IP 프로토콜 위에서 동작
* 모든 데이터를 전송 가능
* http request와 response 메시지를 주고 받는다.

### 1.3.1 HTTP 메시지의 구조

HTTP 메시지 구조

| 스타트라인        |    헤더     |       빈줄       |     바디     |
| ------------ | :-------: | :------------: | :--------: |
| 요청라인 또는 상태라인 | 헤더는 생략 가능 | 헤더의 끝을 빈 줄로 식별 | 바디는 생략  가능 |

스타트라인은 요청 메시지일 때 요청라인(request line)이라고 하고, 응답 메시지일 때 상태라인(status line)이라고 한다.
헤더는 각 행의 끝에 CRLF(Carriage Return Line feed)가 있으며 헤더와 바디는 빈 줄로 구분한다.
바디에는 텍스트, 바이너리 데이터가 들어갈 수 있다.

#### 요청 메시지

바디가 없음

```
get /Book/shakespear HTTP/1.1
Host: www.example.com:8080
```

첫 번째 줄은 요청라인으로, `요청 방식(method), 요청 URL, 프로토콜 버전` 으로 구성된다
두 번째 줄은 헤더로, `이름: 값` 형식으로 표현하며 헤더는 여러 줄도 가능하다.

#### 응답 메시지

```
HTTP/1.1 200 OK
Content-Type: application/xhtml+xml; charset=utf-8

<html>
...
</html>
```

첫 번째 줄의 상태 라인은 `프로토콜 버전, 상태 코드, 상태 텍스트`로 구성됨
`200 OK`이므로 정상적으로 처리되었음을 알 수 있다.

헤더

바디는 보통 HTML 텍스트가 포함되어있다.

### 1.3.2 HTTP 요청 방식


| 메소드명    | 의미                 | CRUD와 매핑되는 역할 |
| ------- | ------------------ | ------------- |
| GET     | 리소스 취득             | Read          |
| POST    | 리소스 생성, 리소스 데이터 추가 | Create        |
| PUT     | 리소스 변경             | Update        |
| DELETE  | 리소스 삭제             | Delete        |
| HEAD    |
| OPTIONS |
| TRACE   |
| CONNECT |

#### GET

지정한 URL의 정보를 가져오는 메소드

#### POST, PUT

`POST` 리소스를 생성하는 메소드
`PUT` 리소스를 변경하는 메소드

#### DELETE

`DELETE` 리소스를 삭제하는 메소드

### 1.3.3 GET, POST 메소드

GET

URL 부분의 `?` 뒤에 `이름=값` 쌍으로 이어붙여 보낸다.

```
GET http://docs.djangoproject.com/search/?q=forms&release=1 HTTP/1.1
```

POST

GET에서 URL에 포함시켰던 파라미터들을 아래 예시처럼 요청 메시지의 바디에 넣는다.

```
POST http://docs.djangoproject.com/search/  HTTP/1.1
Content-Type: application/x-www-form-urlencoded

q=form&release=1
```

### 1.3.4 상태코드 Status Code

#### 상태 코드 분류

| 메소드명 | 의미            | CRUD와 매핑되는 역할                 |
| ---- | ------------- | ----------------------------- |
| 1xx  | Informational | 임시적인 응답                       |
| 2xx  | Success       | 클라이언트의 요청이 서버에서 성공적으로 처리됨     |
| 3xx  | Redirection   | 완전한 처리를 위해서 추가적인 동작을 필요로 함    |
| 4xx  | Client Error  | 클라이언트의 요청 메시지 내용이 잘못된 경우      |
| 5xx  | Server Error  | 서버측 사정에 의해 메시지 처리에 문제가 발생한 경우 |

#### 자주 사용되는 상태코드

2xx, Success
* 200
  * OK
* 201
  * Created
  * 새로운 리소스 생성
* 202
  * Accepted
  * 요청 접수, 처리 완료 x

3xx, Redirection
* 301
  * Moved Permanently
  * 지정한 리소스가 새로운 URI로 이동
* 303
  * See Other
  * 다른 위치로 요청
* 307
  * Temporary Redirection
  * 임시로 리다이렉션 요청이 필요함

4xx, Client Error
* 400
  * Bad Request
  * 요청의 구문 오류
* 401
  * Unauthorized
  * 지정한 리소스에 대한 엑세스 권한이 없음
* 403
  * Forbidden
  * 지정한 리소스에 대한 엑세스가 금지됨
* 404
  * Not Found
  * 지정한 리소스를 찾을 수 없음

5xx, Server Error
* 500
  * Internal Server Error
* 502
  * Bad Gateway
* 503
  * Service Unavailable

## 1.4 URL 설계

URL의 구성

* URL 스킴
  * URL에 사용된 프로토콜
* 호스트명
  * 웹 서버의 호스트명
  * 도메인명 또는 IP 주소로 표현
* 포트번호
  * 웹 서버 내의 서비스 포트번호
  * 생략시 디폴트 번호
    * http
      * 80
    * https
      * 443
* 경로
  * 파일, 애플리케이션 경로
* 쿼리스트링
  * 질의 문자열
  * 앰퍼샌드(&)로 구분된 `이름=값`쌍 형식으로 표현
* 프라그먼트
  * 문서 내의 앵커

### 1.4.1 URL을 바라보는 측면

URL은 웹 클라이언트에서 호출한다는 시점에서 보면, `웹 서버에 존재하는 애플리케이션에 대한 API(Application Programming Interface)`라고 할 수 있다.

웹 프로그래밍의 API 명명 규칙을 정하는 두 가지 방법
1. RPC
   * Remote Procedure Call
   * 클라이언트가 네트워크상에서 원격에 있는 서버가 제공하는 api 함수를 호출하는 방식
   * 쿼리 파라미터를 함수의 인자로 간주
   * URL 경로의 대부분이 동사가 됨
   * 웹 개발 초기부터 사용된 방식
   * 예시
     * `http://blog.example.com/search?q-test&debug=true`
2. REST
   * Representational State Transfer
   * 웹 서버에 전재하는 요소들을 모두 리소스라고 정의하고, URL을 통해 웹 서버의 특정 리소스를 표현한다는 개념
   * 리소스는 상태(state)가 변할 수 있기 때문에 클라이언트와 서버 간에 데이터의 교환을 리소스 상태의 교환(Representational State Transfer)으로 간주
   * 리소스에 대한 조작을 GET, POST, PUT, DELETE 등의 HTTP 메소드로 구분
   * 웹 클라이언트에서 URL을 전송하는 것이 웹 서버에 있는 리소스 상태에 대한 데이터를 주고받는 것으로 간주될 수 있음
   * 예시
     * `http://blog.example.com/search/test`

### 1.4.2 간편(Clean) URL

간편(Clear) URL
 * 쿼리스트링 없이 경로만 가진 간단한 구조의 URL
 * 검색 엔진의 처리를 최적화하기 위해 생겨남
   * a.k.a
     * 검색엔진 친화적 URL(search engine frinedly url)
     * 사용자 친화적 URL(user friendly url)

### 1.4.3 파이썬의 우아한(Elegant) URL

URL을 정의하기 위해 정규표현식(Regular Expression)을 추가적으로 사용

### 1.5 앱 에플리케이션 서버

웹 서버를 세분화하면 웹 서버와 웹 애플리케이션 서버로 구분 가능.

* 웹 서버
  * 웹 클라이언트의 요청 처리 후 그 결과를 웹 클라이언트에게 응답
  * 정적페이지인 HTML, 이미지, CSS, JS 파일을 웹 클라이언트에 제공할 때 사용
  * 동적 페이지 처리가 필요하다면 웹 애플리케이션 서버에 처리를 넘김
  * 예시 프로그램 명
    * Apache httpd
    * Nginx
    * lighttpd
    * IIS
* 웹 애플리케이션 서버
  * 웹 서버로부터 동적 페이지 요청을 받아서 요청을 처리 후 그 결과를 웹 서버로 반환
  * 동적 페이지 생성을 위한 프로그램 실행과 데이터베이스 연동기능을 처리
  * 예시 프로그램 명
    * Apache Tomcat
    * JBoss
    * WebLogic
    * WebSphere
    * Jetty
    * Jeus
    * mod_wsgi
    * uWSGI
    * Gunicorn

### 1.5.1 정적 페이지 vs 동적 페이지

* 정적 페이지
  * 항상 같은 내용을 표시하는 웹 페이지
  * 동일한 리소스(URL)의 요청에 대해서 항상 동일한 내용의 페이지를 반환
  * 예시
    * HTML, CSS, JS, 이미지만으로 이루어진 페이지
* 동적 페이지
  * 동일한 리소스의 요청이라도 누가, 언제, 어떻게 요구했는지에 따라 각각 다른 내용이 반환되는 페이지
  * 예시
    * 현재 시각을 보여주는 페이지
    * 온라인 쇼핑 사이트에서 사용자마다 다른 카트 내용을 보여주는 페이지

정적(static), 동적(dynamic)이란 용어는 사용자가 페이지를 요청하는 시점에 페이지의 내용이 유지/변경되는지 구분해주는 용어

동적 페이지에는 프로그래밍 코드가 포함되어있어 페이지 요청 시점에 HTML 문장을 만듦

* CGI(Common Gateway Interface) 
  * 별도의 프로그램과 웹 서버 사이에 정보를 주고받는 규칙을 정의
  * 생긴 이유
    * 동적 페이지에 대한 요구사항이 생김
    * 데이터베이스 처리에 대한 요구가 많아짐

### 1.5.2 CGI 방식의 단점

CGI 자체는 웹 서버와 독립적인 프로그램(프로세스) 사이에 정보를 주고받는 규격
규격 준수시 어떤 언어를 사용해도 CGI 프로그램 개발 가능

* 근본적인 문제점
  * 각각의 클라이언트 요청에 대하여 별도의 프로세스가 생성
    * 요청이 많아질수록 프로세스가 많아짐
    * 비례적으로 프로세스가 점유하는 메모리 요구량이 커져 시스템에 많은 부하를 줌

### 1.5.3 CGI 방식의 대안 기술

1. `웹 서버 내장` 방식
   * 별도의 애플리케이션(CGI 프로그램과 같은 역할을 하는 프로그램)을 스크립트 언어(Perl, PHP)로 작성하고, 스크립트를 처리하는 스크립트 엔진(인터프리터)을 웹 서버에 내장시켜서 CGI 방식
   * mod_perl, mod_php
     * Perl이나 PHP 스크립트 엔진을 웹 서버에 내장시켜 애플리케이션의 처리를 고속화하기 위해 개발된 기술
   * Python
     * mod_wsgi 모듈 사용
     * mod_python 사용 정지
2. `데몬` 방식
   * 애플리케이션을 처리하는 프로세스를 미리 데몬으로 기동시켜 놓은 후, 웹 서버의 요청을 데몬에서 처리하는 것
   * 프로세스 생성의 부하를 줄일 수 있는 방법
   * Python
     * 데몬방식에도 mod_wsgi 모듈을 사용
     * mod_wsgi
       * 웹 서버 내장 방식
       * 데몬 방식

JSP, ASP 기술에서 애플리케이션 서버 방식을 사용

* Python에서 웹 서버와 연동용으로 사용하는 프로그램
  * mod_wsgi
  * uwsgi
  * gunicorn
* httpd, nginx와는 별개의 애플리케이션 전용 데몬으로 동작하기에 웹 애플리케이션 서버라고 할 수 있음

### 1.5.4 애플리케이션 서버 방식

* 애플리케이션 서버 방식
  * 웹 서버가 웹 애플리케이션 서버를 통해 웹 애플리케이션 프로그램을 실행하는 방식
  * 웹 애플리케이션 서버 --(애플리케이션 프로그램의 실행 결과)--> 웹 서버 --(응답 결과)--> 웹 클라이언트

* 애플리케이션 서버 방식에서의 서버 간 구성도
  * 웹 클라이언트
    * 요청, 응답
  * 웹 서버
    * 처리 위임, 결과 반환
  * 웹 애플리케이션 서버
    * DB 연동
  * DB 서버

서로의 역할을 구분하여 사용하기

* 웹 서버
  * 정적 페이지를 웹 클라이언트에게 제공
  * 캐시, 프록시 기능
  * 동시에 접속을 허가하는 클라이언트 수의 제한 및 처리 프로세스의 관리,
  * 요청 및 응답에 관한 로그의 기록
  * 안정성 확보를 위한 인증 제어 및 암호화 처리 등 HTTP/HTTPS의 제어에 필요한 기능
* 웹 애필리케이션 서버
  * 대다수의 웹 애플리케이션 서버는 웹 클라이언트로부터 직접 요청을 받아 처리하는 웹 서버의 기능을 제공
  * 성능과 안정성 측면에선 적합하지 않다.
    * 개발용으로 제한적으로 사용
    * 운용 환경이나 대규모 사이트에서는 잘 사용되지 않는다.
  * 예시
    * Java - Tomcat
    * Ruby - Unicorn
    * Python - uWSGI
  
### 1.5.5 웹 서버의 역할과 구분

* 이전의 웹 서버/웹 애플리케이션 서버라는 용어는 SW 측면의 서버 프로그램을 의미
* HW 측면의 용어는 웹 서버 박스 및 웹 애플리케이션 서버 박스라는 용어를 사용

웹 서버와 웹 애플리케이션 서버를 구성하는 방식

* 동일한 HW 박스에서 기동하는 방식
  * 서비스 운용 관리 측면에서 좀 더 간편함
* HW 박스를 분리하여 구성하는 방식
  * 메모리 효율을 더욱 높일 수 있음
  * 웹 서버 박스와 웹 애플리케이션 서버 박스 간의 메모리 사이즈 비율을 조절 가능
    * 해당 웹 사이트의 트래픽 중 정적 페이지와 동적 페이지 요청 건수 비율을 분석해야함
  * 대형 웹 사이트에서는 구분하여 구성하는 것이 보통이다.
    * HW 측면에서 L4 또는 L7 스위치 및 리버스 프록시 HW 박스 등의 도입을 고려하여 구성하게 됨